---
title: "HW2"
author: "Div Dasani"
date: "October 15, 2018"
output:
  word_document: default
  html_document: default
---
##A. Developing the envelope and squeeze functions
####Let
####$f(x) = e^{-|x^3|/3}$
####Then
####$log(f(x)) = -|x^3|/3$
####The log of the envelope function can be constructed by taking a tangent line to the curve at $x = ±h$ and connecting them at the origin. Define
####$j(h,x) = -d/dx(logf(x))(h)|x| + logf(h) + |h|^3 = -h^2|x| + logf(h) + |h|^3$
####For this exercise, I define my envelope function as 
####$e(x) = e^{j(1,x)} = e^{2/3-|x|}$ 
####and therefore
####$log(e(x)) = 2/3 - |x|$
####Since I used $h = 1$ in my envelope function, let the squeeze funtion be defined as
####$s(x) = f(1) = e^{-1/3}, x\epsilon(-1,1)$
####and therefore
####$log(s(x)) = -1/3, x\epsilon(-1,1)$
##B. Create GInv function:
####$\int_{-\infty}^{\infty} e(x) \; dx = 2e^{\frac{2}{3}}$
####Define the density function $g$ as
####$g(y) = \frac{e(y)}{2e^{\frac{2}{3}}}$
####Then the CDF of $g$ is given by
####$G(y) = [(e^y/2, y>0),(1-\frac{1}{2e^y}, y<0)]$
####We can now compute the inverse of the CDF, which is given by
####$G^{-1}(u) = [(log(2u), u<\frac{1}{2}),(-log(2(1-u)), u>\frac{1}{2})]$
##C. Adaptive Rejection Sampling Algorithm
####The algorithm works as follows:
####1. Sample $Y$~$g$
####2. Sample $U$~Unif$(0,1)$
####3. If $U <= s(Y)/e(Y)$, keep $Y$ for $x$
####4. If $U > s(Y)/e(Y)$ and $U <= f(Y)/e(Y)$, keep $Y$ for $x$
####5. Otherwise, reject $Y$
####6. repeat $n$ times
##D. Approximating $E[X^2]$
####1. Square all values of $Y$ which were kept
####2. Sum all these squared values
####3. Divide this sum by the total number of $Y$ values kept
####4. Report this value.
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r p1}

logf <- function(x) {      
  -abs(x^3)/3
}
logfe <- function(x) {        
  -abs(x) + 2/3
}
logfs <- function(x) {            
  ifelse( (x>-1)&(x<1), -1/3, NA);
}

f <- function(x) {         
  exp(logf(x))
}
fe <- function(x) {     
  exp(logfe(x));
}
fs <- function(x) { 
  exp(logfs(x));
}


Ginv <- function(y) {
  ifelse( y<0.5, log(2*y), -log(2*(1-y)) );
}

ars <- function(n) { 
  y <- rep(NA,n);
  i <- 0;                      
  j <- 0;                      
  i1 <- 0;    
  
  while(i<n) {
    g <- Ginv(runif(1));
    u <- runif(1);
    if( (g>-1)&&(g<1) ) {
      if( u < fs(g)/fe(g)){
          i<-i+1;
          y[i]<-g;
          i1<-i1+1;
      } else {
        if( u < f(g)/fe(g) ) {
          i<-i+1; y[i]<-g;
        } 
      }
    } else if( u < f(g)/fe(g) ) {
      i<-i+1;
      y[i]<-g;
    } 
    j <- j + 1;
  }
  list(y=y, acratio.sx=i1/j, acratio=i/j);
}

temp <- ars(1000)

# theoretical envelope ratio
integrate(f, lower=-Inf,upper=Inf)$value/integrate(fe, lower=-Inf,upper=Inf)$value
#actual envelope ratio
temp$acratio

# theoretical squeeze ratio
integrate(fs, lower=-1,upper=1)$value/integrate(fe, lower=-Inf,upper=Inf)$value
# actual squeeze ratio
temp$acratio.sx

print(paste("E[X^2] = ", sum(temp$y^2)/1000))

```